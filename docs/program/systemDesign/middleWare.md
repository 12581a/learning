# 消息中间件

* **MQ的优势**

应用解耦：提高系统容错性和可维护性

异步提速：提升用户体验和系统吞吐量

削峰填谷：提高系统稳定性

* **MQ的劣势**

系统可用性降低，系统稳定性越差。一旦MQ宕机，就会对业务造成影响

系统复杂性提高

一致性问题

①生产者不需要从消费者处获得反馈，使异步成为可能

②容许短暂的不一致

## RabbitMQ简介

### AMQP

高级消息队列协议 : 一个进程间传递异步消息的网络协议 ，类似于HTTP

 ![图片描述](http://img.blog.csdn.net/20160310091724939)

**工作过程**

发布者（Publisher）发布消息（Message），经由交换机（Exchange）。

交换机根据路由规则将收到的消息分发给与该交换机绑定的队列（Queue）。

最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。

**AMQP messaging 中的基本概念**

- **Broker**: 接收和分发消息的应用，RabbitMQ Server就是Message Broker。
- **Virtual host**: 出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue等。
- **Connection**: publisher／consumer和broker之间的TCP连接。断开连接的操作只会在client端进行，Broker不会断开连接，除非出现网络故障或broker服务出现问题。
- **Channel**: 如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。
- **Exchange**: message到达broker的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。
- **Queue**: 消息最终被送到这里等待consumer取走。一个message可以被同时拷贝到多个queue中。
- **Binding**: exchange和queue之间的虚拟连接，binding中可以包含routing key。Binding信息被保存到exchange中的查询表中，用于message的分发依据。

JMS是API规范接口

### 工作模式

**RabbitMQ的六种工作模式**

#### 简单模式

![](https://img-blog.csdnimg.cn/20181221114009759.png)

1. 消息产生着§将消息放入队列
2. 消息的消费者(consumer) 监听(while) 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失)应用场景:聊天(中间有一个过度的服务器;p端,c端)

#### 工作队列模式

![](https://img-blog.csdnimg.cn/20181221114036231.png)

1. 消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2,同时监听同一个队列,消息被消费者C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)
2. 应用场景:红包;大项目中的资源调度(任务分配系统不需知道哪一个任务执行系统在空闲,直接将任务扔到消息队列中,空闲的系统自动争抢)

#### 发布订阅模式

![](https://img-blog.csdnimg.cn/20181221114050657.png)

1. X代表交换机rabbitMQ内部组件,erlang 消息产生者是代码完成,代码的执行效率不高,消息产生者将消息放入交换机,交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费
2. 相关场景:邮件群发,群聊天,广播(广告)

Exchange:交换机X。一方面，接收生产者发送的消息，另一方面，知道如何处理消息，例如递交给某个特定队列、递交给所有队列、或是将消息丢弃。Exchange有常见的以下三种类型：

Fanout Exchange：广播，将消息交给所有绑定到交换机的队列

Direct Exchange ：定向，把消息交给符合指定routing key的队列

Topic Exchange：通配符，把消息交给符合routing pattern(路由模式)的队列

#### routing路由模式

![](https://img-blog.csdnimg.cn/20181221114420299.png)

1. 消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;
2. 根据业务功能定义路由字符串
3. 从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误;

#### topic 主题模式

![](https://img-blog.csdnimg.cn/20181221114208408.png)

1. 星号井号代表通配符
2. 星号代表多个单词,井号代表一个单词
3. 路由功能添加模糊匹配
4. 消息产生者产生消息,把消息交给交换机
5. 交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费

  ### 高级特性

#### 消息的可靠投递

rabbitmq整个消息投递的路径为：

Producer -> rabbitMQ Server -> exchange -> queue -> consumer

在使用RabbitMQ的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败的场景。RabbitMQ为我们提供了两种方式来控制消息的投递可靠性模式。

**confirm 确认模式:**消息从producer到exchange则会返回一个confirmCallback。

**return 退回模式:**消息从exchange到queue投递失败则会返回一个returnCallback。

我们可以利用这两个callback控制消息的可靠性投递。 

#### Consumer ACK

表示消费端收到消息后的确认方式。

三种确认方式：none:自动确认；manual：手动确认；根据异常确认

如果在消费端没有出现异常，则调用channel.basicAck(deliveryTag, true)方法确认签收消息

如果出现异常，channel.basicNack(deliveryTag, true, true);则消息重回到queue,broker会重新发送

#### 消费端限流

Consumer限流：

1. 确保ack机制为手动确认

2. listener-container配置属性 prefetch = 1 : 表示消费端只从mq拉取一条消息来消费，直到手动确认消费完毕后，才会继续拉取下一条消息

#### TTL

Time To Live（存活时间）

当消息到达存活时间后，还没有被消费，会被自动清除。

RabbitMQ可以对消息设置过期时间，也可以对整个队列设置过期时间。

如果设置了消息的过期时间，也设置了队列的过期时间，它以短的时间为准。

队列过期后，会将队列中的所有消息全部移除

消息过期后，只有消息在队列顶端，才会判断是否移除。

####  死信队列

Dead Letter Exchange(死信交换机)，当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。

消息成为死信的三种情况：

队列消息长度到达限制，超过的消息成为死信；

消费者拒绝消费消息，basicNack，并且不把消息重新放入原目标队列，requeue=false;

原队列存在消息过期设置，消息到达超时时间未被消费。

#### 延迟队列

延迟队列，即消息进入队列后不会被立即消费,只有达到指定时间后，才会被消费

可以使用TTL+死信队列组合实现延迟队列的效果。只需要设置队列的过期时间即可。

需求：新用户注册后，发送短信问候

### RabbitMQ应用问题

消息可靠性保障：消息补偿机制

消息幂等性保障：乐观锁解决方案（如何防止重复消费）

**幂等性**：用户对于同一操作发起的一次请求或者多次请求的结果是一致的

## Rabbit常见面试问题

**1.RabbitMQ 如何保证消息不丢失？如何解决**

 **A:生产者丢失消息**： 开启rabbitmq事物，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降，所以可以开启confirm确认模式

 **B:rabbitmq自己弄丢了数据** ：设置消息持久化到磁盘。设置持久化有两个步骤：
①创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据。
②发送消息的时候将消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时rabbitmq就会将消息持久化到磁盘上。
必须要同时开启这两个才可以。

而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进行消息重发。

 **C:消费者弄丢了数据** 

rabbitmq有手动ack机制与自动ack机制来解决消费者弄丢数据：
如果使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，使用手动ack，每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。

但是ack机制在异常情况下可能造成重复消费：当消费者异常断掉连接，但并未挂掉，broker 会得知， 此时broker 尚未获得 ack，那么消息会被重新放入其他队列，这样就导致数据被重复消费了。

**消息补偿机制**

**2.如何防止重复消费**

让每个消息携带一个全局的唯一ID，即可保证消息的幂等性，具体消费过程为：

1. 消费者获取到消息后先根据id去查询redis/db是否存在该消息。
2. 如果不存在，则正常消费，消费完毕后写入redis/db。
3. 如果存在，则证明消息被消费过，直接丢弃。

业务逻辑判断：消息执行完会更改某个实体状态，判断实体状态是否更新，如果更新，则不进行重复消费。

