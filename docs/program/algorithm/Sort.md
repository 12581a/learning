### 最常用的排序——快速排序 

假设我们现在对“6  1  2  7  9  3  4  5  10  8”这 10个数进行排序。首先在这个序列中随便找一个数作为**基准数**（不要被这个名词吓到了，这就是一个用来参照的数，待会儿你就知 道它用来做啥了）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中 所有比基准数大的数放在 6的右边，比基准数小的数放在 6的左边，类似下面这种排列。 

**3  1  2  5  4  6  9  7  10  8** 

在初始状态下，数字 6在序列的第 1位。我们的目标是将 6挪到序列中间的某个位置， 假设这个位置是 k。现在就需要寻找这个 k，并且以第 k位为分界点，左边的数都小于等于 6， 右边的数都大于等于 6。想一想，你有办法可以做到这点吗？ 给你一个提示吧。请回忆一下冒泡排序是如何通过“交换”一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？方法其实很简单：分别从初始序列“6  1  2  7  9  3  4  5  10  8”两端开始“探测”。先从 右往左找一个小于 6的数，再从左往右找一个大于 6的数，然后交换它们。这里可以用两个 变量 i和 j，分别指向序列左边和右边。我们为这两个变量起个好听的名字“哨兵 i”和 “哨兵 j”。刚开始的时候让哨兵 i指向序列的左边（即 i=1），指向数字 6。让哨兵 j指向序 列的右边（即 j=10），指向数字 8。 

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/1111.PNG)

首先哨兵 j开始出动。因为此处设置的基准数是左边的数，所以需要让哨兵 j先出动， 这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j--），直到找到 一个小于 6的数停下来。接下来哨兵 i再一步一步向右挪动（即 i++），直到找到一个大于 6 的数停下来。后哨兵 j停在了数字 5面前，哨兵 i停在了数字 7面前。 

 ![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/22222.PNG)

现在交换哨兵 i和哨兵 j所指向的元素的值。交换之后的序列如下。 

**6  1  2  <u>5</u>  9  3  4  <u>7</u>  10  8**

到此，第一次交换结束。接下来哨兵 j继续向左挪动（再次友情提醒，每次必须是哨兵 j先出发）。他发现了 4（比基准数 6要小，满足要求）之后停了下来。哨兵 i也继续向右挪 动，他发现了 9（比基准数 6要大，满足要求）之后停了下来。此时再次进行交换，交换之 后的序列如下。 

**6  1  2  5  <u>4</u>  3  <u>9</u>  7  10  8**

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/33333.PNG)

  第二次交换结束，“探测”继续。哨兵 j继续向左挪动，他发现了 3（比基准数 6要小， 满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨 兵 i和哨兵 j都走到3面前。说明此时“探测”结束。我们将基准数 6和 3进行交换。交换之后的序列如下。 

**<u>3</u>  1  2  5  4  <u>6</u>  9  7  10  8** 

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/4444.PNG)

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/55555.PNG)

到此第一轮“探测”真正结束。此时以基准数 6为分界点，6左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j的使命就是要找小于基准数的数， 而哨兵 i的使命就是要找大于基准数的数，直到i和 j碰头为止。 OK，解释完毕。现在基准数 6 已经归位，它正好处在序列的第 6 位。此时我们已经将 原来的序列，以 6为分界点拆分成了两个序列，左边的序列是“3  1  2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列，因为 6左边和右边的序列目前都还是很混 乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6左边和右 边的序列即可。现在先来处理 6左边的序列吧。如果你模拟得没有错，调整完毕之后的序列的顺序应该是： 
**2  1  3  5  4** 
OK，现在 3已经归位。接下来需要处理 3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以 2为基准数进行调整，处理完毕之后的序列为“1 2”，到此 2已经归位。序列 “1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到 的序列是“1 2”。序列“5 4”的处理也仿照此方法，后得到的序列如下。 
**1  2  3  4  5  6  9  7  10  8 **
对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。终将会得到这样的序列：

**1  2  3  4  5  6  7  8  9  10 **

到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。

快速排序之所以比较快，是因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的差时间复杂度和冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。其实快速排序是基于一 种叫做“二分”的思想。它的java 代码如下： 

```java
public static int[] quickQuery(int a[],int begin,int end) {
        if (begin < end) {
            int temp = a[begin];
            int i = begin;
            int j = end;
            while(i != j) {
                while(i < j && a[j] >= temp) {
                    j--;
                }
                while(i < j && a[i] <= temp){
                    i++;
                }
                if(i < j){
                   int t = a[j];
                   a[j] = a[i];
                   a[i] = t;
                }
            }
            a[begin] = a[i];
            a[i] = temp;
            quickQuery(a,begin,j-1);
            quickQuery(a,j+1,end);
        }else{
            return a;
        }
        return a;
    }
```