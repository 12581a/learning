# 数据结构与算法

基础的结构：链表、数组、队列、栈、二叉树、堆、图的定义等

基础的算法：排序、二分查找、二叉树的遍历、图的广度和深度优先算法、字符串朴素匹配算法

基础的算法思想：递归、分治、贪心、回溯、动态规划

**重点**：时间空间复杂度、适合解决什么问题、应用场景、原理、代码实现

## 1.排序

**算法复杂度：**

![](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

* 插入排序
* 快速排序
* 归并排序
* 堆排序

## 2.链表

链表是以节点的方式来存储，每个节点包含data域，nex域：指向下一个节点。链表分带头的链表和没有头结点的链表，根据实际的需求来确定。

头插法：新节点始终是在头结点的后面插入

```java
if(head != null){
    newNode.next = head;
    head = newNode;
}
```

尾插法：在尾部插入

## 3.算法思想

### 二分法

取中位数的索引：

```java
int mid = left + (right - left) / 2;
```

`int mid = (left+right)/2`这样的代码是有问题的，`left + right`很有可能超过int类型能表示的最大值，即整型溢出

循环条件：

```java
while(left <= right);
```

当`int mid = left + (right - left + 1) / 2`,得到的是右中位数的索引，这个可以用`int mid = (left + right + 1) >>> 1`来替换。`>>>`为无符号右移运算符。

### 递归

每个递归函数都有两部分：基线条件 （base case）和递归条件 （recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再 调用自己，从而避免形成无限循环。 

递归的要素

1. **「确定递归函数的参数和返回值：」**确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **「确定终止条件：」**写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **「确定单层递归的逻辑：」**确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 贪心算法

所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 

### 动态规划

基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 

总结
动态规划问题通常用于计算多阶段决策问题的最优解。

多阶段，是指解决一个问题有多个步骤；
最优解，是指「最优子结构」。
动态规划有三个概念很重要：

重复子问题：因为重复计算，所以需要「空间换时间」，记录子问题的最优解；
最优子结构：规模较大的问题的最优解，由各个子问题的最优解得到；
无后效性（上面已经解释）。
动态规划有两个特别关键的步骤：

设计状态：
有些题目问啥，就设计成什么；
如果不行，只要有利于状态转移，很多时候，就可以设计成状态；
根据过往经验；
还有一部分问题是需要在思考的过程中调整的，例如本题。
推导状态转移方程：通常是由问题本身决定的。
动态规划问题思考的两个方向：

自顶向下：即「递归 + 记忆化」，入门的时候优先考虑这样做；
自底向上：即「递推」，从一个最小的问题开始，逐步得到最终规模问题的解。后面问题见得多了，优先考虑这样做，绝大部分动态规划问题可以「自底向上」通过递推得到。
相关练习
「力扣」第 376 题：摆动序列（中等）；
股票系列 6 道问题：区别仅在于题目加了不同的约束。一般来说有一个约束，就在「状态设计」的时候在后面多加一维，消除后效性，这个系列里最难的问题，也只有 2 个约束，因此状态设计最多 3 维。增加维度使得状态设计满足无后效性，是常见的解决问题的技巧。

「力扣」第 121 题：买卖股票的最佳时机（简单）；
「力扣」第 122 题：买卖股票的最佳时机 II（简单） ；
「力扣」第 123 题：买卖股票的最佳时机 III（困难）；
「力扣」第 188 题：买卖股票的最佳时机 IV（困难）；
「力扣」第 309 题：最佳买卖股票时机含冷冻期（中等）；
「力扣」第 714 题：买卖股票的最佳时机含手续费（中等）。
打家劫舍系列的两道问题都很典型：

「力扣」第 198 题：打家劫舍（简单），第 213 题：打家劫舍 II（中等） 基于这个问题分治（分类讨论）做；
「力扣」第 337 题：打家劫舍 III（中等），树形 dp 的入门问题，依然是加一个维度，使得求解过程具有无后效性，使用后序遍历，完成计算。

## 4.字符串



## 5.树

满二叉树

完全二叉树

* 二叉树的顺序存储

* 二叉树的链式存储

* 二叉树的遍历：

  a.递归遍历：先序遍历【DLR】、中序遍历【LDR】、后序遍历【LRD】

  ```java
//中序遍历思路
  栈S;
p= root;
  while(p || S不空){
    while(p){
          p入S;
          p = p的左子树;
      }
      p = S.top 出栈;
      访问p;
      p = p的右子树;
  }
  ```
  
  b.层次遍历：从上到下，从左到右
  
  ```java
  void bfs(TreeNode root) {
      Queue<TreeNode> queue = new ArrayDeque<>();
      queue.add(root);
      while (!queue.isEmpty()) {
          TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
          if (node.left != null) {
              queue.add(node.left);
          }
          if (node.right != null) {
              queue.add(node.right);
          }
      }
  }
  ```
  
  c.非递归的遍历
  
  由二叉树的先序和后序能够确定一个二叉树
  
  **完全二叉树使用场景：**
  
  根据前面的学习，我们了解到完全二叉树的特点是：“叶子节点的位置比较规律”。因此在对数据进行排序或者查找时可以用到它，比如堆排序就使用了它，后面学到了再详细介绍。

二叉树的变形

* 二叉排序树（BST）

  二叉排序树又称二叉查找树。或者为空树，或者是具有以下性质：

  （1）若它的左子树不为空，则左子树所有节点的值小于根结点，

  （2）若它的右子树不为空，则根结点的值小于所有右子树结点的值

  （3）它的左右子树叶分别为二叉排序树

  总结起来就是根据结点的值有：左子树<根结点<右子树

  二叉排序树中序遍历的结果是有序的序列

  查找、插入、删除算法

* 平衡二叉树（AVL）

   性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。  增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。

   平均查找长度（ASL）

   构造二叉树的方法：插入过程中，采用平衡旋转技术。 

   **1.为什么要有平衡二叉树**

   二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树，依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。

   失衡调整旋转平衡处理：

   ​	（1）单项右旋（LL）

   ​	（2）单项左旋（RR）

   ​	（3）先左后右（LR）

   ​	（4）先右后左（RL）

* 哈夫曼树及哈夫曼编码

   ​	构造最优树

* 堆排序

   堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 

**B树：**

又称平衡多路查找树

1. 平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树
2. 平衡二叉树每个节点只有一个数据和两个指向孩子的指针，而 B 树每个中间节点有 k-1 个关键字（可以理解为数据）和 k 个子树（ k 介于阶数 M 和 M/2 之间，M/2 向上取整）
3. B 树的所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null

和平衡二叉树相同的点在于：B 树的节点数据大小也是按照左小右大，子树与节点的大小比较决定了子树指针所处位置。

B 树的每个节点可以表示的信息更多，因此整个树更加“矮胖”，这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度。

* **B+树**

B+树的特征：

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

## 6.图

图的遍历

* 深度优先搜索(DFS）：类似于树的递归

* 广度优先搜索(BFS)：类似于树的层次

## 7.散列表

散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 

哈希查找需要做两方面的事情，选择一个“好”的哈希函数；提供一种“处理冲突的方法”。

冲突处理办法：

* 开放地址法

（1）线性探测再散列

（2）平方探测再散列

（3）随机探测再散列

 * 再哈希法
 * 链地址法

将所有哈希地址相同的记录都链接在同一个链表中。

* 公共溢出区法

常见的散列函数：

* **MD5**

**MD5** 是输入不定长度信息，输出固定长度 128-bits 的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits 散列。

* **SHA-1**

SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。 



​	





























































