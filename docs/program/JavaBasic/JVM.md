# JVM概述

## 1.运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。 

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/jvmdata.png)

### 程序计数器

一块较小的内存空间，它是**当前线程所执行的字节码的行号指示器**，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。

当线程在执行一个 Java 方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是 Native 方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在 Java 虚拟机规范中么有规定任何 OOM（内存溢出：OutOfMemoryError）情况的区域。

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

### Java 虚拟机栈

该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。 每一个方法从调用到方法执行完成，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

在 Java 虚拟机规范中，对这个区域规定了两种异常情况：

- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
- 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

1.只有在调用一个方法时，才为当前栈分配一个帧，然后将该帧压入栈

2.帧中存储了对应方法的局部数据，方法执行完，对应的帧则从栈中弹出，并把返回结果存储在调用方法的帧的操作数栈中

### 本地方法栈

该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。  方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。 

### Java堆

Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

根据 Java 虚拟机规范的规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。

> 堆和栈的区别
>
> - 功能不同
>
>   - 栈内存用来存储局部变量和方法调用。
>
> - 而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
>
> - 共享性不同
>
>   - 栈内存是线程私有的。
>   - 堆内存是所有线程共有的。
>
> - 异常错误不同
>
>   如果栈内存或者堆内存不足都会抛出异常。
>
>   - 栈空间不足：java.lang.StackOverFlowError。
>   - 堆空间不足：java.lang.OutOfMemoryError。
>
> - 空间大小
>
>   栈的空间大小远远小于堆的。

### 方法区

方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于 Sun HotSpot 来讲 。

它存储了每一个类的结构信息。例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容，上面讲的是规范，在不同的虚拟机里面实现是不一样的的，最典型的就是永久代和元空间。

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 

### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 

 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池 

## 2.HotSpot虚拟机对象探秘

### 对象的创建

#### 1.类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### 2.分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

 **内存分配的两种方式** ：

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/distribute.png)

 **内存分配并发问题** :

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的， 对象分配内存不是线程安全的，比如给对象A分配内存，还没来得及修改指针的指向， 另一个线程创建对象B也用了原来的指针，这样就会出问题的。 通常来讲，虚拟机采用两种方式来保证线程安全：

（1） 对分配内存空间的动作进行同步处理 

 实际上虚拟机采用CAS配上失败重试的方式保证更新指针操作的原子性 

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

（2） 把内存分配的动作按照线程划分在不同的空间中进行 

即：每个线程在java堆中预分配一小块内存， 这一小块内存称作“本地线程分配缓冲"（Thread Local Allocation Buffer, TLAB） 

*  **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 

#### 3.为对象的成员变量赋初始值 

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### 4.设置对象头

对象头是什么？对象头的作用是记录对象在运行过程中所需的数据。

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### 5.执行 init 方法

从上面对象的创建过程，我们可以了解到，在内存分配完成之后，所有成员变量的值都还只是零值。对于虚拟机来说，对象创建已经完毕，但是，对于java程序来说，对象的初始化才刚开始。成员变量的初始化工作交由**init**方法的来完成。编译器收集了成员变量上的赋值操作，实例初始化代码块的赋值操作，以及构造方法中的赋值操作，构成**init**方法，并执行，对象就得到了初始化。学习过java基础的人都知道，对象初始化的顺序为: 成员变量上的赋值-->实例初始化块-->构造方法。

init方法就解释了为什么是这个过程。

### 对象的内存布局

 在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。 

* 实例数据

实例数据存储的是成员变量的值，包括从父类继承下来的成员变量。

成员变量在内存中的顺序：相同宽度的字段会分配在一起，父类定义的变量会出现在子类之前， 默认情况下，子类中较窄的变量可能会被插入到父类变量的间隙中。反正就是不一定按定义的顺序来分配。

* 对象头是什么？

对象头的作用是记录对象在运行过程中所需的数据。

比如对象属于哪个类的实例、所属类的信息在方法区中的位置（类型指针）、对象的哈希码、对象的GC分代年龄等信息。这些信息就保存在对象头中（Object Header）

* 对齐填充又是什么？

对齐填充是用于确保对象的内存的总长度为8字节的整数倍。

为什么要是确保是8字节的整数倍呢？

因为hotspot要求对象起始地址为8字节的整数倍以便于自动内存管理， 换句话说，对象的总长度要为8字节的整数倍才能保证如此。 而又因为对象头正好是8字节（32位或64位）的整数倍，但是实例数据长度是任意的，因此需要对齐补充来确保整个对象总长度为8字节的整数倍。

### 对象的访问定位

java程序需要通过引用来操作堆上的具体数据。 根据引用存放的地址类型的不同，对象有不同的访问方式

主要有两种访问方式： 使用句柄访问 和  使用直接指针访问

1. **句柄：** 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/句柄.png)

1. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/zjzhi.png)

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

## 3.类文件结构

## 4.虚拟机加载机制

### 类加载过程

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 

#### 1.加载

类加载过程的第一步，主要完成下面3件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

 一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。 

##### 类加载器的分类

- 启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在`JDK\jre\li`(JDK 代表 JDK 的安装目录，下同)下，或被`-Xbootclasspath`参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，所有的`java.*`开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。
- 扩展类加载器：Extension ClassLoader，该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载`JDK\jre\lib\ext`目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库（如`javax.*`开头的类），开发者可以直接使用扩展类加载器。
- 应用程序类加载器：Application ClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载

##### 双亲委派模型

当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，如果上级的类加载器没有加载，自己才会去加载这个类。 

即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

#### 2.验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 文件格式的验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
- 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合 Java 语法规范的元数据信息。
- 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
- 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

#### 3.准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。
3. 
   - 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
   - 对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
   - 对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
   - 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

#### 4.解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 

#### 5.初始化

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 

 #### 6.卸载

卸载类即该类的Class对象被GC。

卸载类需要满足3个要求:

1. 该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被GC

所以，在JVM生命周期类，由jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk自带的BootstrapClassLoader,PlatformClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

## 5.垃圾收集器

#### 堆的划分

![](https://cdn.jsdelivr.net/gh/12581a/cdn/images/hea.png)

​    虚拟机中的共划分为三个代：

​	年轻代（Young Generation）、年老代（Old    Generation）和持久代（Permanent  

​    Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系  

​    不大。年轻代和年老代的划分是对垃圾收集影响比较大的。

>  **在Java8中移除了永生代，取而代之是元空间(Metaspace)** 
>
> - 移除了永久代（PermGen），替换为元空间（Metaspace）
> - 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
> - 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；
> - 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

MinorGc的过程（复制-->清空-->互换）

## 6.堆参数调优

元空间与永久代之间最大的区别：

永久带使用的是JVM的堆内存，但是Java8以后的元空间并不在虚拟机中而是使用本机物理内存。

#### 垃圾回收算法

1.引用计数法

2.复制算法

3.标记清除

4.标记压缩 

## 7 性能调优

常用调优工具：VisualVM、JProfiler











































































