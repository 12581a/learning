# Java基础 

## stringbuffer 和 stringbuilder的区别

String类被final关键字修饰，意味着String类不能被继承 ，String实例的值是通过字符数组实现字符串存储的。StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder中也是使用字符数组保存字符串，但是没有用 final 关键字修饰，所以这两种对象都是可变的。 

`StringBuilder`是非线程安全的， `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 

## 深拷贝与浅拷贝

浅拷贝对于基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 

深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 

## == 与 equals

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。

 **equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 一种是覆盖了equals方法，一种是没有覆盖。 

## hashCode 与 equals

以HashSet为例，当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 `equals()`方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。 

如果`a`和`b`相等，那么`a.equals(b)`一定为`true`，则`a.hashCode()`必须等于`b.hashCode()`； 要重写这两个方法。

## Java反射机制

在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用，我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制； 

在程序运行期间，Java 运行时系统始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类名为 Class。 

优点是运行时动态获取类的全部信息，缺点是破坏了类的封装性，泛型的约束性。 

反射的应用：Spring框架通过配置文件加载对象，Spring的IOC容器、JDBC中加载驱动 

## Java中的引用类型有哪几种？

强引用：即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象，JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。 

软引用：即SoftReference<byte[]> s = new SoftReference<byte[]>(new byte[1024 * 10])这种引用关系。 只有当内存不足时，JVM才会去回收该对象，其他情况不会回收 。适合做缓存。

弱引用： 只有弱引用的对象，当JVM触发gc时，就会回收该对象。与软引用不同的是，不管是否内存不足，弱引用都会被回收。 

虚引用：如果一个对象只有虚引用在引用它，垃圾回收器是可以在任意时候对其进行回收的，虚引用主要用来跟踪对象被垃圾回收器回收的活动，当被回收时，JVM会把这个弱引用加入到与之相关联的ReferenceQueue中。

## 序列化，反序列化

Java序列化就是指把Java对象转换为字节序列的过程。

Java反序列化就是指把字节序列恢复为Java对象的过程。

实现序列化功能需要实现 `java.io.Serializabale` 标记接口 

Java 对象在 JVM 运行时被创建，当 JVM 退出时存活对象都会销毁，如果需要将对象及其状态持久化，就需要通过序列化来实现，将对象及其状态信息保存在字节数组中，在需要时再将这些字节数组反序列化为对象。对象序列化保存的是对象的状态，因此类中的静态变量不会被序列化，因为静态变量是类属性。 

除了静态变量外，transient 修饰的变量也不会被序列化。transient 的作用就是把这字段的生命周期仅限于内存中而不会写到磁盘里持久化，被 transient 修饰的变量会被设为对应数据类型的默认初始值。 

## 异常实现及分类

Error：OutOfMemoryError

Exception： IOException/RuntimeException

## 接口和抽象类的区别

抽象类不能创建实例，它只能作为父类被继承。 

一个非抽象类继承抽象类，必须将抽象类中的抽象方法覆盖，实现重写。

# JavaScript基础

## 原型链

原型对象：构造函数在创建的过程中，系统自动创建出来与构造函数相关联的一个空的对象。可以由构造函数.prototype来访问到。 

每一个对象都有自己的原型对象，原型对象本身也是对象，原型对象也有自己的原型对象，这样就形成了一个链式结构，叫做原型链。 

# Java集合类

## ArrayList 与 LinkedList 区别?

Arraylist 底层使用的是 Object 数组；在往数组中添加指定元素前，首先要考虑的就是其容量是否饱和。若接下来的添加操作会时数组中的元素超过其容量，则必须对其进行扩容操作。 扩容后的容量是原容量+原容量右移一位 ，受限于数组容量固定不变的特性，扩容的本质其实就是创建一个容量更大的新数组，再将旧数组的元素复制到新数组当中去。LinkedList 底层使用的是双向链表数据结构。 所以，对于随机访问，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。

ArrayList与LinkedList都不是线程安全的。

ArrayList的扩容机制：

在JDK1.8中，如果通过无参构造的话，初始数组容量为0，当真正对数组进行添加时（即添加第一个元素时），才真正分配容量，默认分配容量为10；当容量不足时（容量为size，添加第size+1个元素时），先判断按照1.5（位运算）的比例扩容。 

**Vector中的操作是线程安全的**。 

## HashMap、Hashtable区别？

HashMap的底层是由数组+链表实现的，在1.7的时候它的数据节点是一个Entry数组，在1.8的时候当链表长度大于阈值，默认为8（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。 

HashMap 是非线程安全的，HashTable 是线程安全的 ，HashTable 内部的方法基本都经过`synchronized` 修饰。Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。 

**扩容机制：** 

HashMap在put的时候，插入的元素超过了阈值 （由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，会使用到头插法， 新旧链表的元素位置会发生转置现象，在多线程的环境下，这种头插法可能会导致环状节点。导致在get时会出现死循环，所以HashMap是线程不安全的。

在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况。 

在JDK1.8中,在并发执行put操作时会发生数据覆盖的情况。  

## HashMap 的长度为什么是2的幂次方

HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀。Hash值的范围很大，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&(length-1)，

## ConcurrentHashMap

JDK1.7的 ConcurrentHashMap 底层采用分段的数组+链表实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。

在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 但是查询遍历链表效率太低。  到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本。

# Java并发

## 什么是线程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。

线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。

Java中线程具有五种状态：初始化、可运行、运行中、阻塞、销毁。

协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

## java创建线程的方式

继承Thread类 、实现Runnable接口、使用线程池

Callable可以在任务结束之后提供一个返回值。Runnable不可以。
Callable中call（）方法可以抛出异常。Runnable中的run（）方法不可以。
Callable运行过程中可以拿到一个Future对象，可以用来监视目标线程调用call（）方法的情况。

## 说说 sleep() 方法和 wait() 方法区别和共同点?

两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。
两者都可以暂停线程的执行。
Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。

**为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？**

new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

## ThreadLocal

ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。 

ThreadLocal可以保证线程安全，你创建了 一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。

ThreadLocal得到当前线程的ThreadLocalMap，然后把ThreadLocal对象和value值设置set进去，这个key是该ThreadLocal的实例的弱引用，set方法是利用new一个Entry实现的，Entry继承了WeakReference类并且super(t1)。当`Entry`使用强引用，即使`t=null`,但key的引用依然指`ThreadLocal`对象,所以会有内存的泄露，而使用若引用则不会，但是还是有内存泄露存在，`ThreadLocal`被回收，key 的值变为了`null`，则导致整个value再也无法访问到，因此依旧存在内存泄露，因此使用完毕后要记得调用 ThreadLocal 的 remove 方法删除对应线程的 threadLocals 中的本地变量。

## synchronized 关键字

synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 

synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。

## volatile关键字

Volatile:指令重排序、可见性、内存屏障

当一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。 当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。

**synchronized和volatile的区别？**

synchronized则是锁定当前的变量，只有当前线程可以访问到该变量，其他的线程将会被阻塞。

volatile只能实现变量的修改可见性，并不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。

volatile只能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

**Java指令重排序**:

编译期指令重排：编译器做的优化

运行期指令重排：CPU乱序执行带来的

写Volatile变量时，可以确保Volatile写之前的操作不会被编译器重排序到Volatile写之后。读Volatile变量时，可以确保Volatile读之后的操作不会被编译器重排序到Volatile读之前。

## ReentrantLock和synchronized的区别

先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：

非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；

公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。

**ReentrantLock和synchronized的区别**

相似点：都是阻塞式的同步。可重入，同一线程可以多次获得同一个锁。都保证了可见性和互斥性

不同点：

①Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁 

②synchronized的锁是非公平锁，ReentrantLock默认情况下也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。 

③等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可等待特性对处理执行时间非常长的同步快很有帮助。

ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性

## CAS操作是什么？

compare and swap ， CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。 

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。 

应用于AtomicInteger 类

ABA问题：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。 

在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验。 

## 锁有哪些

根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。 而非公平锁则在运行时闯入，也就是先来不一定先得。

根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。
独占锁保证任何时候都只有一个线程能得到锁， ReentrantLock 就是以独占方式实现 的。 共享锁则可以同时由多个线程持有，例如 ReadWriteLock 读写锁，它允许一个资源可 以被多线程同时进行读操作。

当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，这就是可重入锁

自旋锁则，当前线程在获取锁时，如果发现锁已经被其他线程占有， 它不马上阻塞自己，在不放弃 CPU 使用权的情况下，多次尝试获取，很有可能在后面几次尝试中其他线程己经释放了锁。 如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。

## 说一下synchronized的锁升级过程 

无锁：无线程个数约束，没有synchronized、lock修饰/做同步控制

偏向锁：只有一个线程访问

轻量级锁：2个线程交替访问

重量级锁：多线程并发访

一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。

一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。

## 使用线程池的好处

①减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

②运用线程池能有效的控制线程最大并发数，可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

③ 对线程进行一些简单的管理，比如：延时执行、定时循环执行的策略等，运用线程池都能进行很好的实现

## ThreadPoolExecutor

  ```java
new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,
RejectedExecutionHandler handler)
  ```

**七大参数**

corePoolSize（线程池的基本大小）、maximumPoolSize（线程池最大大小）、runnableTaskQueue（任务队列）、ThreadFactory：用于设置创建线程的工厂、RejectedExecutionHandler（拒绝策略）、keepAliveTime（线程活动保持时间）、TimeUnit（线程活动保持时间的单位）

**四种拒绝策略**

①AbortPolicy：丢弃任务并抛出RejectedExecutionException异常

②DiscardPolicy：丢弃任务，但是不抛出异常 

③DisCardOldSetPolicy：丢弃队列最前面的任务，然后提交新来的任务

④CallerRunPolicy：由调用线程（提交任务的线程，主线程）处理该任务

## Java通过Executors提供四种线程池

①CachedThreadPool()：可缓存线程池。

线程数无限制

有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销

②  FixedThreadPool()：定长线程池 

可控制线程最大并发数（同时执行的线程数）

超出的线程会在队列中等待

③ ScheduledThreadPool()

定时线程池。
支持定时及周期性任务执行。

④ SingleThreadExecutor()：单线程化的线程池。

有且仅有一个工作线程执行任务

所有任务按照指定顺序执行，即遵循队列的入队出队规则

## 线程死锁

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象， 在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去

# JVM

## 对象的生命周期和创建

创建阶段：为对象分配存储空间、开始构造对象、递归调用其超类的构造方法、进行对象实例初始化与变量初始化、执行构造方法体。

应用阶段：系统至少维护着对象的一个强引用。

最后垃圾回收器发现该对象已经不可到达，就会回收。  

 **对象的创建/实例化的步骤：**

① 类加载检查：

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

② 分配内存：分配方式有 “指针碰撞”和“空闲列表”

③为对象的成员变量赋初始值 ：

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

④ 设置对象头

对象头的作用是记录对象在运行过程中所需的数据。

比如对象属于哪个类的实例、所属类的信息在方法区中的位置（类型指针）、对象的哈希码、对象的GC分代年龄等信息。这些信息就保存在对象头中（Object Header）

⑤执行 init 方法

属性的显式初始化、代码块的初始化、构造器中的初始化

## JVM内存模型 

运行时数据区域：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。 

方法区和堆是线程共享的；程序计数器和本地方法栈及虚拟机栈都是每个线程一份。 

 **2.1程序计数器作用：**

用于存储下一条字节码指令的地址，执行引擎执行完当前指令，根据程序计数器的地址执行下一条指令。 

**2.2虚拟机栈的作用**

  ①每个线程在创建时都会创建一个虚拟机栈，内存存储一个一个栈帧，正在执行的方法对应着一个一个栈帧。 

  ②主管java程序的运行，保存方法的局部变量（8种基本数据类型及对象的引用地址）、部分结果参与方法的调用及返回。

**2.3 JVM对虚拟机栈的操作有什么？**

  ①每个方法执行，伴随着入栈。  ②方法执行结束出栈。

**2.4 虚拟机栈常见两个异常** 

 ①：stackOverFlow: JVM允许用户自己设置虚拟机栈的大小为固定值，当方法数过多，致使栈帧数量超过虚拟机栈的大小时，就会报stackOverFlow; 

 ②：OutOfMemoryError：Java虚拟机栈容量允许扩展，当无法申请到足够的内存时，会报OOM异常。

**2.5 堆空间的概述**

​	**2.5.1 设置堆内存大小**

​	a.-Xms：设置堆空间（新生代+老年代）的起始内存大小

​	b.-Xmx：设置堆空间（新生代+老年代）的最大内存大小

**2.6 方法区**

 用于存储已经被虚拟机加载的类信息，常量，静态变量等 

**2.8 永久代/元空间**

永久代和元空间都是方法区的实现，永久代在JDK1.7之前放在堆区，在JDK1.8之后放在了直接内存中

元空间回收：

每一个类加载器的存储区域都称作一个元空间。只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。 

## 内存分配策略

a. 优先分配到新生代；

b. 大对象直接分配到老年代；

c. 长期存活的对象（s0，s1区中年龄计算器值超过设定阈值或默认阈值15）分配到老年代；

## 垃圾回收

判断对象存活算法：引用器计数法和可达性分析算法

**在可达性分析算法中：Java内存区域中可以作为GC ROOT的对象** 

①虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量。

②方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。

③方法区中常量引用的对象，譬如字符串常量池的引用。

④本地方法栈中引用的对象

**垃圾回收算法**

​	**标记-清除算法**: 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象 

缺点：第一个是执行效率不稳定，如果Java堆中包含大量对 象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过 程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题 。

​	**标记-复制算法**： 将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉 

缺点： 是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点

​	**标记-整理算法** ： 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存  

**分代收集理论：**

**什么是年轻代？什么是老年代？**

**为什么分为新生代和老年代** 

不同对象的生命周期是不同的，70%-90%的对象的生命周期是短暂的，在新生代主要存放生命周期短暂的对象，在老年代存放新生代中经过多次垃圾回收之后依然没有没有被回收的对象，这样做主要是为了优化GC的性能 

存储在堆中的Java对象可以分类两类，一类是新生代，一类是老年代；  通过-XX:SurrRatio的值进行调节；默认  的是8：1：1；实际使用时不为8：1：1，因为存在自适应内存分配策略（默认开启） 

  **新生代**：一类是声明周期较短的瞬时对象，这类对象从创建到消亡时间较短暂；新生代包括伊甸园区，两个幸存区。

  **老年代**：一类对象的声明周期比较长，在极端情况下还可能与JVM的声明周期一致；

 	new出来的对象会被存储在伊甸园区，然后当伊甸园区的空间被占满后，此时会YGC，将没有被其他对象所引用的对象进行回收，然后将伊甸园区剩余对象加载到Survivor 0区（from区），并将年龄标记为1，再加载新的对象放在伊甸园区。 

​	如果再次触发YGC垃圾回收，上次放在幸存者0区的对象会放在幸存者1区，年龄标记+1.然后伊甸园区幸存下来的对象会被放到幸存者1区，年龄标记为1，然后幸存者1区变为from区，幸存者0区变为to区； 

 	如果再次发生YGC，则会重复此过程，当from区的幸存对象的标记年龄超过15后，则会移动到老年代中；如果存在着大于伊甸园区的对象，则会直接进入到老年代中；当老年代内存不足时，会触发GC，进行老年代回收；

 	对幸存者1区2区：**复制后交换**，谁空谁为to区；频繁在新生代收集，较少在老年代收集，几乎不在永久代/元空间收集 

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用**复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。

在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用**标记-清理算法**或者**标记-整理算法**来进行回收。

**大对象直接进入老年代**： 最典型的大对象就是那种很长的字符串以及数组

**长期存活的对象将进入老年代**

**动态对象年龄判定**

为了能更好地适应不同程度的内存状况，虚拟机并不是永远地要求对象的年龄必须达到 `MaxPretenuringThreshold`才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无需等到`MaxPretenuringThreshold`中要求的年龄。

## Hot Spot经典垃圾收集器

①**Serial收集器** ：  JDK1.3.1前是HotSpot新生代收集的唯一选择； 

特点：针对新生代；采用复制算法；单线程收集；进行垃圾收集时，必须暂停所有工作线程，直到完成；即会**（STW）"Stop The World"；**

应用场景 ： Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。 

②**ParNew收集器**： ParNew垃圾收集器是Serial收集器的多线程版本。 能搭配CMS使用

特点：除了多线程外，其余的行为、特点和Serial收集器一样； 

③**Parallel Scavenge收集器**：Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为吞吐量收集器。

特点： 新生代收集器；采用复制算法；多线程收集； 目标则是达一个可控制的吞吐量 ，通过减少新生代的内存达到少收集的目的，减小stw时间。 开启`-XX:+UseAdptiveSizePolicy`这个参数， JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略 。

④**Serial Old收集器**： Serial Old是 Serial收集器的老年代版本； 

特点： 针对老年代；采用"标记-整理"算法，还有压缩，单线程收集；

⑤**Parallel Old收集器**： Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本； 

特点：针对老年代；采用"标记-整理"算法；多线程收集；

应用场景：特别是在Server模式，多CPU的情况下；这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的"给力"应用组合。

⑥**CMS收集器**： 并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器或低延迟垃圾收集器

特点：针对老年代；基于"标记-清除"算法(不进行压缩操作，产生内存碎片)；以获取最短回收停顿时间为目标；并发收集、低停顿；需要更多的内存。第一次实现了让垃圾收集线程与用户线程（基本上）同时工作； 

应用场景 ：与用户交互较多的场景；希望系统停顿时间最短，注重服务的响应速度；以给用户带来较好的体验；

如常见WEB、B/S系统的服务器上的应用；

**三色标记过程：**

**黑色**：根对象，以及该对象与它的子对象都被扫描过。

***灰色***：对象本身正在被扫描，其子对象还未被扫描。

***白色***：未被扫描的对象。如果扫描完所有对象后仍为白色，则被判定根不可达，即为垃圾。

三色标记的过程中，标记线程和用户线程是并发执行的，那么就有可能在我们标记过程中，用户线程修改了引用关系，把原本应该回收的对象错误标记成了存活，即会发生漏标的问题： 

**对象消失问题：**扫描过程中插入了一条或多条从黑色对象到白色对象的新引用，并且同时去掉了灰色对象到该白色对象的直接引用或间接引用。

**解决方案**：

（1） **增量更新**：打破了第一个条件。当A插入新的引用关系D时，就将这个插入的引用记录的A对象记录下来。等待扫描结束后的重新标记阶段，再把这些记录过的引用了新对象的对象再次变为灰色。就会重新对A再进行一次扫描。 

（2）**原始快照**：打破了第二个条件。把灰色对象指向白色对象的删除记录下来，到了最终标记阶段，会把灰色对象变为GCRoots，无论之后的对象是否存活，一律按照快照中的存活状态全部进行扫描。

总结： CMS关注新增，但是会把新增对象的前一个引用变为灰色，重新对所有子对象进行遍历，有一定性能损耗。G1引用的打破，不需要重新遍历对象，因此效率较高。但是维护快照，以及其保守策略增加了一定的内存成本。 

过程：

初始标记

并发标记

重新标记

**G1垃圾回收**： 

G1是一个全年代的垃圾回收器，它将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个，内存的回收是以region作为基本单位的； 新生代垃圾回收的时机是当新生代的Region数量扩充到60%的时候，触发一次垃圾回收。可以指定停用的预期时间，会在复制的时候挑选最有价值的Redion进行回收

G1垃圾回收器的分代也是建立在这些Region的基础上的。对于Region来说，它会有一个分代的类型，并且是唯一一个。即，每一个Region，它要么是young的，要么是old的。还有一类十分特殊的Humongous。所谓的Humongous，就是一个对象的大小超过了某一个阈值——HotSpot中是Region的1/2，那么它会被标记为Humongous。如果我们审视HotSpot的其余的垃圾回收器，可以发现这种对象以前被称为大对象，会被直接分配老年代。而在G1回收器中，则是做了特殊的处理。

**Rset:**记录其他Region引用与当前Region

**Cset:**本次GC需要清理的Region集合

**young gc**

发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。

#### mixed gc

当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。

mixed gc的执行过程有点类似cms，主要分为以下几个步骤： 

initial mark: 初始标记过程，整个过程STW，标记了从GC Root可达的对象

concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息

remark: 最终标记过程，整个过程STW，标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对象

clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中

## 类的生命周期类加载过程  

Java类的生命周期就是指一个class文件从加载到卸载的全过程。 

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。 

## 双亲委派机制

①：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委托给父类的加载器去执行；

②：如果父类加载器还存在父类加载器，则会继续向上委托，请求最终达到顶层的引导类加载器；

③：如果父类引导器可以完成加载任务，则成功返回；否则子加载器会尝试自己执行，这就是双亲委派机制。

2.双签委派模型的优势：

①：避免类的重复加载；

②：沙箱安全机制：保护程序安全，防止核心类库被随意更改（举例：自定义一个java.lang.String类）

怎么破坏双亲委派机制 ？

重写ClassLoader中的loadClass()方法 

# 计算机网络

## 输入一个url后的过程；浏览器从发送请求的全部过程

DNS域名解析；经过TCP三次握手之后建立TCP连接；发送HTTP请求，服务器处理请求；返回响应结果；关闭  TCP连接；浏览器解析HTML；浏览器布局渲染；

## OSI七层模型/五层模型，每一层有哪些协议

五层模型分别是物理层、数据链路层、网络层： IP、ICMP  传输层： TCP、UDP 、应用层 ：SMTP、DNS

 HTTP、TFTP 、 Telnet  ，七层的话还有会话层、表示层。

## TCP，UDP协议的区别

① TCP面向连接， UDP是无连接的，即发送数据之前不需要建立连接

②TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

③TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的,UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低

④每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

⑤TCP首部开销20字节;UDP的首部开销小，只有8个字节

⑥TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 

## TCP协议如何实现流量控制和网络堵塞

①通信双方主机上都分别有一个“发送窗口”和一个“接受窗口”

②TCP连接阶段，双方协商窗口尺寸

③发送方根据协商的结果，发送符合窗口尺寸的数据字节流，并等待对方的确认，等待确认机制

④发送方根据确认信息，改变窗口的尺寸

## TCP如何保证可靠传输的

TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 

## TCP三次握手四次分手

 第一次握手：客户端给服务器发送一个 SYN 报文，指明客户端的序列号x,请求建立连接

 第二次握手： 服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号序列号，同时会把客户端的序列号 + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，可以建立连接

 第三次握手： 客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文 ，确认建立连接

![](https://img-blog.csdn.net/20180717201939345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**在四次分手时，**

**第一次**：客户端发送一个FIN报文，报文中会指定一个序列号 

**第二次：**服务器确认客户端的断开请求，会发送ACK报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了

**第三次：** 如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号 

**第四次**： 客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。

* **为什么需要三次握手**？

通过三次握手确认双方收发功能都正常，四次也可以但是显得比较多余。 

* **TCP三次握手，如果两次握手会怎么样？**

如果一个连接请求在网络中跑的慢，超时了，这时客户端会从发请求，但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！

如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接受到的连接确认请求就可以抛弃不管了。

* **tcp四次挥手为什么要四次？**

   TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。 
   
   TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 

**为什么客户端最后还要等待2MSL？** 

客户端需要保证最后一次发送的ACK报文到服务器，如果服务器未收到，可以请求客户端重发，这样客户端还有时间再发，重启2MSL计时。 

##  HTTP 常见的状态码，有哪些？

①2xx类状态码表示服务器成功处理了客户端的请求 

②3xx类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 

③4xx类状态码表示客户端发送的报文有误，服务器无法处理 

④5xx类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 

## 8. **GET 请求和 POST 请求的区别** 

①GET产生一个TCP数据包；POST产生两个TCP数据包。 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

②GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

③GET参数通过URL传递，POST放在Request body中。

④ GET请求会被浏览器主动cache，而POST不会，除非手动设置。 

##  9. cookie与session的区别

①http协议是无状态的，不需要额外的资源来记录状态信息，这能减轻服务器的负担 

②cookie数据保存在客户端，session数据保存在服务器端。

③ Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

## 10. HTTP 1.0和HTTP 1.1的主要区别是什么?

在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,   每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。而 HTTP1.1默认使用长连接 ,默认开启Connection： keep-alive。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 

## 11. HTTP 与 HTTPS

① HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

② HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

③ HTTP 的端口号是 80，HTTPS 的端口号是 443。

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

## 12. Https怎么加密 

某网站拥有用于非对称加密的公钥A1、私钥A2。

①浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。

②浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。

③服务器拿到后用私钥A2解密得到密钥X。

④这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。

**传送证书**
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

**客户端解析证书**
这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。

**传送加密信息**
这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

**服务端加密信息**
服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。

# Mysql

## 1. 数据库的隔离级别

MySql默认的隔离级别是：可重复读

| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |
| -------------------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED(读未提交) | √    | √          | √    |
| READ-COMMITTED(读已提交)   | ×    | √          | √    |
| REPEATABLE-READ(可重复读)  | ×    | ×          | √    |
| SERIALIZABLE(串行化)       | ×    | ×          | ×    |

脏读： 事务B读取事务A还没有提交的数据 。

不可重复读： 指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。 

幻读:对同一张表的两次查询不一致，因为另一事务插入了一条记录。

总的来说，解决不可重复读的方法是**锁行**，解决幻读的方式是 **锁表**。

**读未提交**：并发最高，一致性最差的隔离级别。

**串行化**：一致性最好的，性能最差。

## 2. MyISAM和InnoDB区别

①InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 

②InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； 

③InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁；

④InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。

⑤InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而MyISAM可以没有。

## 3. InnoDB为什么推荐使用自增ID作为主键

自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

## 4. 数据库中索引B+树

在Mysql的InnoDB引擎中，自适应哈希索引就是用哈希表实现的，但因为哈希表本身是无序的，所以不利于范围查询，于是我们希望数据的组织方式是有序的，我们想到了使用二分查找， 但是显然有序数组对于插入和删除并不友好，有没有这样一种数据结构，既有一定顺序，又方便插入和删除呢？事实上，基于二分查找的思想，诞生了这样一种数据结构：二分查找树。但是当元素有序时，会退化成一个链表，于是诞生了二叉平衡树。

当然，维护平衡二叉树也是需要一定开销的，即当树插入/更新/删除新的数据时假设破坏了树的平衡性，那么需要通过左旋和右旋来维护树的平衡。

当数据量很多时，同样也会出现二叉树过高的情况。

我们知道平衡二叉树的查找效率为 O(log n)，也就是说，当树过高时，查找效率会下降。

另外由于我们的索引文件并不小，所以是存储在磁盘上的。

文件系统需要从磁盘读取数据时，一般以页为单位进行读取，假设一个页内的数据过少，那么操作系统就需要读取更多的页，涉及磁盘随机I/O访问的次数就更多。

将数据从磁盘读入内存涉及随机I/O的访问，是数据库里面成本最高的操作之一。

因而这种树高会随数据量增多急剧增加，每次更新数据又需要通过左旋和右旋维护平衡的二叉树，不太适合用于存储在磁盘上的索引文件，于是诞生了B树。

**B树：**又称平衡多路查找树

1. 平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树
2. 平衡二叉树每个节点只有一个数据和两个指向孩子的指针，而 B 树每个中间节点有 k-1 个关键字（可以理解为数据）和 k 个子树（ k 介于阶数 M 和 M/2 之间，M/2 向上取整）
3. B 树的所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null

和平衡二叉树相同的点在于：B 树的节点数据大小也是按照左小右大，子树与节点的大小比较决定了子树指针所处位置。

B 树的每个节点可以表示的信息更多，因此整个树更加“矮胖”，这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度。

* **B+树**

B+树的特征：

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

## 5. 最左前缀匹配原则和覆盖索引

联合索引：就是好几个字段组成的索引，称为联合索引。

在mysql建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配， 

MySQL 建立联合索引的规则是这样的，它会首先根据联合索引中最左边的、也就是第一个字段进行排序，在第一个字段排序的基础上，再对联合索引中后面的第二个字段进行排序，依此类推。

综上，第一个字段是绝对有序的，从第二个字段开始是无序的，这就解释了为什么直接使用第二字段进行条件判断用不到索引了（从第二个字段开始，无序，无法走 B+ Tree 索引）！这也是 MySQL 在联合索引中强调最左前缀匹配原则的原因。

覆盖索引：对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。

## 6. B+ 树和 B 树的区别？

①B树非叶子结点和叶子结点都存储数据,因此查询数据时，时间复杂度最好为O(1),最坏为O(log n)。

②B+树只在叶子结点存储数据，非叶子结点存储关键字，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为O(log n)。

③B+树叶子结点之间用链表相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B树只能通过中序遍历。

## 7. 为什么 B+ 树比 B 树更适合应用于数据库索引？

①B+树更加适应磁盘的特性，相比B树减少了I/O读写的次数。由于索引文件很大因此索引文件存储在磁盘上，B+树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机I/O读取次数相对就减少了。

②B+树的查询效率相比B树更加稳定，由于数据只存在在叶子结点上，所以查找效率固定为O(log n)。

③B+树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+树的效率更高。

## 8. 数据库sql怎么优化 

（1）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

（2） 尽量使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表

## 9. 什么情况不能用索引？

对于那些在查询中很少使用或者参考的列不应该创建索引

对于那些定义为text, image和bit数据类型的列不应该增加索引 

## 10. 索引失效的情况

索引查找就是二分嘛，凡是不能二分查找的情况都属于索引失效的情况。 

如果条件中有or，即使其中有条件带索引也不会使用 

like查询是以%开头 

## 11. 事物的四大特性

原子性，所有操作要么全部成功，要么全部失败回滚。

隔离性，当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

一致性，事务执行之前和执行之后都必须处于一致性状态，拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

持久性，一旦事务提交，对数据的改变就是永久的 

## 12. 乐观锁与悲观锁

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：

乐观锁的具体实现细节：冲突检测和数据更新 

使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式 。 读取数据时 ， version值加一 ，当我们提交更新的时候， 判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对 。

在表中增加一个时间戳（timestamp）字段, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。   

当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发，这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制。

悲观锁： 大多数情况下依靠数据库的锁机制实现。

- 共享锁【Shared lock】又称为读锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改

- 排他锁【Exclusive lock】又称为写锁，排它锁就是不能与其他锁共存，获取到排它锁的事务可以对数据进行读取和修改。如果一个事务获取了一个数据行的排它锁，其他事务就不能再获取该行的其他锁（包括共享锁和排它锁）。

 先通过for update的方式进行加锁，然后再进行修改。这是比较典型的悲观锁策略 

## 13. 数据库三大范式

第一范式： 数据表中的每一列(字段)，必须是不可拆分的最小单元，也就是确保每一列的原子性。 

第二范式：确保表中的每列都和主键相关。 也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 

第三范式： 表中的每一列只能依赖于主键 

# redis

## 1. redis的数据结构

Redis支持五种数据类型：string(字符串)，hash(哈希)，list(列表)，set(集合)及zset(sorted set：有序集合)。

## 2. Redis的持久化

**RDB**: 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存中。 即在指定目录下生成一个dump.rdb文件，Redis 重启会通过加载dump.rdb文件恢复数据。 

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化进程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

优点：
1 适合大规模的数据恢复。
2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

缺点：
1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。
2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。

**AOF**: 以日志形式记录每个写操作，将Redis执行过的所有写操作记录下来，只许追加文件但不可以改写文件，redis重启的话就根据日志文件的内容将写的指令从前到后执行一次以完成数据的恢复工作。

* **Redis分布式锁实现**

先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。**如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？**set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！ 

## 3.缓存雪崩、击穿、穿透问题

**雪崩**：存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。

**击穿**：缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。

其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

**穿透**：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。 

（1）缓存穿透我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。

（2）缓存空值

之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。

那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。

这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。

（2） **布隆过滤器** 

布隆过滤器是一种数据结构，垃圾网站和正常网站加起来全世界据统计也有几十亿个。网警要过滤这些垃圾网站，总不能到数据库里面一个一个去比较吧，这就可以使用布隆过滤器。 

为什么 Redis 是单线程的？

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 。 使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程 。

## 4. Redis的内存淘汰策略

LRU算法： 最近最久未使用 

**链表实现：**新数据放在链表头部 ，链表中的数据被访问就移动到链头，链表满的时候从链表尾部移出数据。

Redis中使用的是近似LRU算法，为什么说是近似呢？Redis中是随机采样5个key，然后从中选择访问时间最早的key进行淘汰，因此当采样key的数量与Redis库中key的数量越接近，淘汰的规则就越接近LRU算法 

（1）volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。

（2）allkeys-lru：从数据集中挑选最近最少使用的数据淘汰

ttl : 生存时间 

（3）volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。

 LFU： 最不经常使用页置换算法 

（4）allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。

（5）volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。

 random：随机 

（6）volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。

（7）allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

（8） no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。

* **跳跃表**

跳表的特点：

只能用于元素有序的情况。它的插入、删除、搜索都是O(log n)。

 [Redis 为什么用跳表而不用平衡树？](https://juejin.im/post/57fa935b0e3dd90057c50fbc) 

# spring

## 1. springBean的生命周期

- Bean容器找到配置文件中 Spring Bean 的定义。
- Bean容器利用Java Reflection API创建一个Bean的实例。
- 如果涉及到一些属性值,利用set方法设置一些属性值。
- 如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。
- 如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。
- 如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。
- 与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。
- 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法
- 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。
- 如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。
- 如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法
- 当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。
- 当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。

## 2. spring的AOP原理

动态代理的两类实现：Jdk动态代理与基于继承的代理，两类代理的实现：Jdk代理与Cglib代理。Jdk动态代理只能 基于接口进行动态代理。Cdlib基于继承实现来实现代理，无法对static、final类进行代理,无法对private、static方法进行代理。

静态代理：代理类和被代理类都会实现同一个接口，代理类里面把被代理类的对象作为一个属性，然后就可以用在被代理类的前后加方法。改进：代理类里面把接口对象作为一个属性。

动态代理：jdk动态代理的代理类自动生成

## 3.spring的IOC容器

首先加载并解析上面的配置文件，获取标签中的id和class属性，根据class属性利用反射来创建类对象和设置类属性，最后将Bean注入到Bean容器中。

工厂模式

## 4. springBoot自动装配的原理

Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。 

## 5.spring Bean的作用域

在Spring中，bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者。

目前Spring Bean的作用域或者说范围主要有五种。

| 作用域      | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| singleton   | 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。 |
| prototype   | 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。 |
| request     | 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。 |
| session     | 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。 |
| application | 限定一个Bean的作用域为`ServletContext`的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。 |

## 6. springmvc工作流程

1.用户发送请求至前端控制器DispatcherServlet
 2.DispatcherServlet收到请求调用处理器映射器HandlerMapping。
 3.处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。
 4.DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作
 5.执行处理器Handler(Controller，也叫页面控制器)。
 6.Handler执行完成返回ModelAndView
 7.HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet
 8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器
 9.ViewReslover解析后返回具体View
 10.DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。
 11.DispatcherServlet响应用户。

# 设计模式

## 1. 单例模式

```java
/*
饿汉式:
类加载到内存中，就实例化一个单例，JVM保证线程安全
唯一缺点：不管用到与否，类装载时就完成实例化
*/
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}

/*
懒汉式:
虽然达到了按需加载的目的，但却带来线程不安全的问题
*/
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}

/*
双检锁/双重校验锁
*/
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
/*
静态内部类
*/
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}

/*
枚举
*/
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
} 
```

## 2. 责任链模式

责任链模式(Chain of Responsibility)使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象能够处理它。

## 3. 装饰者模式

主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，
由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
何时使用：在不想增加很多子类的情况下扩展类。

有一个接口，有很多的类去实现它，我们去定义一个抽象的装饰器，如果要让某一个类去扩展功能，
自定义一个实体的装饰器类去继承它。

```java
interface IPancake {
    /**
     * 定义烹饪的操作
     */
    void cook();
}
//具体装饰类EggDecorator
class EggDecorator extends PancakeDecorator {
    public EggDecorator(IPancake pancake) {
        super(pancake);
    }

    @Override
    public void cook() {
        System.out.println("加了一个鸡蛋，");
        super.cook();
    }
}

class HamDecorator extends PancakeDecorator {
    public HamDecorator(IPancake pancake) {
        super(pancake);
    }

    @Override
    public void cook() {
        System.out.println("加了一根火腿，");
        super.cook();
    }
}

class LettuceDecorator extends PancakeDecorator {
    public LettuceDecorator(IPancake pancake) {
        super(pancake);
    }

    @Override
    public void cook() {
        System.out.println("加了一颗生菜，");
        super.cook();
    }
}

class Pancake implements IPancake {

    public void cook() {
        System.out.println("的煎饼");
    }

}

/*
定义抽象装饰类PancakeDecorator
*/
abstract class PancakeDecorator implements IPancake {
    private IPancake pancake;

    public PancakeDecorator(IPancake pancake) {
        this.pancake = pancake;
    }

    public void cook() {
        if (this.pancake != null) {
            pancake.cook();
        }
    }
}

public class Decorator {
    public static void main(String[] args) {
        IPancake pancake = new EggDecorator(new HamDecorator(new LettuceDecorator(new Pancake())));
        pancake.cook();
    }
}
```

## 4. 代理模式

## 5. 观察者模式

意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

## 6. 策略模式

一个系统有许多许多类，而区分它们的只是他们直接的行为。

```java
public class StrategyPatternDemo {
    public static void main(String[] args) {
        Context context = new Context(new OperationSubtract());
        int result = context.doOperation(10, 8)
        System.out.println(result);
    }
}

interface Strategy{
    public int doOperation(int num1, int num2);
}

class OperationAdd implements Strategy{

    @Override
    public int doOperation(int num1, int num2) {
        return num1 + num2;
    }
}

class OperationSubtract implements  Strategy{

    @Override
    public int doOperation(int num1, int num2) {
        return num1 - num2;
    }
}
// 将要使用哪一种策略
class Context implements Strategy{
    private Strategy strategy;
    public Context(Strategy strategy){
        this.strategy = strategy;
    }

    @Override
    public int doOperation(int num1, int num2) {
        return strategy.doOperation(num1,num2);
    }
}
```

# 算法

**快速排序**

首先在这个序列中随便找一个数作为基准数，利用双指针将序列中所有比基准数大的数放在的右边，比基准数小的数放在的左边。 

时间复杂度:O(nlogn)

```java
public static int[] quickSort(int a[],int begin,int end) {
        if(begin<end){
            int i = begin;
            int j = end;
            int temp = a[begin];
            while(i<j && a[j]>=temp){
                j--;
            }
            while(i<j && a[i]<=temp){
                i++;
            }
            if(i<j){
                int flag = a[i];
                a[i] = a[j];
                a[j] = flag;
            }
            a[begin] = a[i];
            a[i] = temp;
            quickSort(a,begin,i-1);
            quickSort(a,i+1,end);
        }
        return a;
    }
```

# RabbitMQ

## **1.RabbitMQ 如何保证消息不丢失？如何解决**

 **A:生产者丢失消息**： 开启rabbitmq事物，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降，所以可以开启confirm确认模式

 **B:rabbitmq自己弄丢了数据** ：设置消息持久化到磁盘。设置持久化有两个步骤：
①创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里面的数据。
②发送消息的时候将消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时rabbitmq就会将消息持久化到磁盘上。
必须要同时开启这两个才可以。

而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进行消息重发。

 **C:消费者弄丢了数据** 

rabbitmq有手动ack机制与自动ack机制来解决消费者弄丢数据
如果使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，使用手动ack，每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。

但是ack机制在异常情况下可能造成重复消费：当消费者异常断掉连接，但并未挂掉，broker 会得知， 此时broker 尚未获得 ack，那么消息会被重新放入其他队列，这样就导致数据被重复消费了。

## **消息补偿机制**

**如何防止重复消费**

让每个消息携带一个全局的唯一ID，即可保证消息的幂等性，具体消费过程为：

1. 消费者获取到消息后先根据id去查询redis/db是否存在该消息。
2. 如果不存在，则正常消费，消费完毕后写入redis/db。
3. 如果存在，则证明消息被消费过，直接丢弃。

业务逻辑判断：消息执行完会更改某个实体状态，判断实体状态是否更新，如果更新，则不进行重复消费。

## **消息成为死信的三种情况：**

队列消息长度到达限制，超过的消息成为死信；

消费者拒绝消费消息，basicNack，并且不把消息重新放入原目标队列，requeue=false;

原队列存在消息过期设置，消息到达超时时间未被消费。

# 秒杀项目

页面缓存，给商品列表加缓存，只缓存前几页

1.判断库存

2.判断是否秒杀过了

3.减库存、下订单、写入秒杀订单，注意@Transactional注解，这是一个事物操作

4.解决超卖问题：卖超则回滚到第三步

​    Redis加锁设置

​	给秒杀订单加唯一索引：防止用户重复购买

​	SQL加库存数量判断：防止库存变成负数

5.秒杀接口优化：

​	系统初始化，把库存数量加载到数据库中

​	收到请求，Redis预减库存，库存不足，直接返回，否则进入下一步

​	请求入队，立即返回排队中

​	请求出队，生成订单，写入到缓存中，然后减少库存

​	客户端轮询订单，是否秒杀成功

**秒杀场景：**

- 秒杀一般是访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功
- 秒杀业务流程比较简单，一般就是下订单减库存 

**秒杀设计原则**

**1. 热点隔离**

秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让1%的请求影响到另外的99%，隔离出来后也更方便对这1%的请求做针对性优化。针对秒杀我们做了多个层次的隔离

业务隔离。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就是已知热点，当真正开始时我们可以提前做好预热